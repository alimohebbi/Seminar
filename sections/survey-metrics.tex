\subsubsection{معیارهای پیش‌بینی خطا}

معیارهای پیش‌بینی خطا نقش مهمی را در ساخت مدل پیش‌بینی ایفا می‌کنند. اکثریت معیارهای پیش‌بینی خطا را می‌توان به دو دسته‌ی  کلی تقسیم کرد: معیارهای کد و معیارهای فرآیند. معیارهای کد می‌توانند به طور مستقیم از کدهای منبع موجود جمع آوری شوند در حالی که معیارهای فرآیند  از اطلاعات تاریخی که در مخازن نرم‌افزاری مختلف آرشیو شده‌اند استخراج می‌گردند. نمونه‌ای از این مخازن نرم‌افزاری سیستم‌های کنترل نسخه و سیستم‌های ردگیری خطا است. معیار‌های فرآیند از نظر هزینه موثر تر از سایر معیارها هستند\cite{arisholm2010systematic}. در برخی از مقالات نیز معیارهای  پیش‌بینی خطا به سه دسته‌ی: معیارهای کد منبع سنتی، معیارهای شئ‌گرایی و معیارهای فرآیند تقسیم شده‌اند\cite{radjenovic2013software}.\\\\
\textbf{معیارهای کد} \\

معیارهای کد تحت عنوان معیارهای محصول\LTRfootnote{Product Metrics}
نیز شناخته می‌شوند و میزان پیچیدگی کد را می‌سنجند. فرض زمینه‌ای\LTRfootnote{Ground Assumption} آنها این است که هرچه کد پیچیده تر باشد خطا‌خیز‌تر است. برای اندازه‌گیری پیچیدگی کد پژوهش‌گران معیار‌های مختلفی را ارائه داده‌اند که در ادامه   مهم ترین آنها معرفی خواهند شد. 
\begin{itemize}
	\item \textbf{معیار اندازه: }
معیارهای "اندازه" اندازه‌ی کلی و حجم کد را می‌سنجند. نماینده‌ی این معیارها "تعداد خطوط" می‌باشد و اولین بار توسط آکیاما \LTRfootnote{Akiyama}
 \cite{akiyama1971example}  
 ارائه شد. هالستد\LTRfootnote{Halstead}
 \cite{halstead1977elements} 
 چندین معیار اندازه بر اساس  تعداد عملگرها و عملوند‌ها ارائه داده است و در مقاله‌ی \cite{pawade2016exploring} مورد بازنگری قرار گرفته است.
\item \textbf{معیار پیچیدگی حلقوی: }
مک‌کیب\LTRfootnote{McCabe} معیارهای "پیچیدگی حلقوی"\LTRfootnote{Cyclomatic}
را پیشنهاد داد که این معیار با استفاده از تعداد گره‌ها، یالها و قطعات متصل در گراف جریان کنترلی\LTRfootnote{Control Flow}  کد منبع محاسبه می‌گردد\cite{mccabe1976complexity}. این معیارها نشان می‌دهند که راه‌های کنترلی به چه میزان پیچیده هستند. باوجود اینکه جز اولین معیارها بوده است همچنان در پیش‌بینی خطا کاربرد دارد \cite{malhotra2014comparative}.
\item \textbf{معیار شئ‌ گرایی: }
با ظهور زبان‌های شئ‌گرایی و محبوبیت آنها معیارهای کد  برای این زبان‌ها ارائه شد تا فرآیند توسعه بهبود یابد. نماینده‌ی معیارهای شئ‌گرایی "چدامبر و کمرر" \LTRfootnote{Chidamber and Kemerer}
(\lr{CK}) می‌باشند\cite{chidamber1994metrics}. این معیارها با توجه به خصیصه‌های زبان‌های شئ‌گرا مانند وراثت، زوجیت، همبستگی\LTRfootnote{Cohesion} طراحی شده‌اند. بجز معیارهای \lr{CK} معیارهای شئ‌گرایی دیگری نیز بر اساس حجم و کمیت کد منبع پیشنهاد داده شده‌اند. مشابه معیارهای "اندازه"، معیارهای شئ‌گرایی تعداد نمونه‌های یک کلاس، توابع را می‌شمارند. \\
\end{itemize}
\textbf{معیارهای فرآیند} \\

در ادامه به بررسی تعدادی از معیارهای فرآیند پرداخته می‌شود که در این دسته شاخص محسوب می‌شوند. 
\begin{itemize}
\item \textbf{تغییر نسبی کد: }
ناگاپان و بال\LTRfootnote{Nagappan and Ball} 8 معیار تغییر نسبی کد را ارائه داده‌اند\cite{nagappan2005use}. به عنوان مثال یکی از معیار‌های آنها تعداد تجمعی خطوط اضافه و حذف شده بین دو نسخه از برنامه را می‌شمارد و بر تعداد خطوط برنامه تقسیم می‌کند. معیار دیگر تعداد فایلهای تغییر یافته از یک قطعه برنامه را بر تعداد  کل فایلها تقسیم می‌کند. 
\item \textbf{تغییر کد: }
این معیارها به عنوان مثال تعداد رفع خطاها، تعداد بازآرایی کد\LTRfootnote{Refactoring} و یا تعداد نویسنگان یک فایل را می‌شمارند. موزر\LTRfootnote{Moser} و همکاران معیارهایی را ارائه داده‌اند که تعداد خطوط اضافه و کم شده را بدون در نظر گرفتن تعداد کل خطوط می‌شمارد. در عوض سن فایل‌ها و تعداد فایلهایی که در سیستم کنترل نسخه ثبت\LTRfootnote{Commit} می‌شوند در نظر گرفته می‌شود \cite{moser2008comparative}. 
\item \textbf{معیار شهرت: }
 بکچلی\LTRfootnote{Bacchelli} و همکاران معیارهای شهرت\LTRfootnote{Popularity} را بر اساس تحلیل ایمیل‌های آرشیو شده‌ی نویسنگان ارائه داده‌اند. ایده‌ی اصلی این معیارها این است که یک قطعه‌ی  نرم‌افزاری که در ایمیل‌ها درباره‌ی آن بیشتر صحبت شده است خطاخیزتر می‌باشد\cite{bacchelli2010popular}. برد و همکاران چهار معیار مالکیت بر اساس نویسندگان یک قطعه ارائه داده‌اند. مالکیت یک قطعه بر اساس نسبت  تعداد ثبت‌های افراد در سیستم کنترل نسخه برای یک قطعه (مشارکت آنها) تعریف می‌شود. \\
\end{itemize}


راجنویک\LTRfootnote{Radjenovic} و همکاران در پژوهش خود به بررسی قاعده‌مند\LTRfootnote{Systematic Review} معیارهای پیش‌بینی خطا در مطالعات پیشین پرداخته‌اند.  طبق این پژوهش در 49\lr{\%} مطالعات از معیارهای شئ‌گرایی، در 27\lr{\%} معیارهای سنتی کد و در 26 \lr{\%} از معیارهای فرآیند استفاده شده است. با توجه به مطالعات بررسی شده دقت پیش‌بینی خطا  با انتخاب معیارهای مختلف، تفاوت قابل توجهی  پیدا می‌کند. معیارهای شئ‌گرایی و فرآیند موفق‌تر از معیارهای سنتی هستند. معیارهای سنتی  پیچیدگی کد، قویا با معیارهای اندازه مانند تعداد خطوط کد همبستگی دارند و این دو توانایی پیش‌بینی خطا دارند اما جز بهترین معیارها نیستند. معیارهای شئ‌گرایی بهتر از اندازه و پیچیدگی عمل می‌کنند و با این که با معیارهای اندازه همبستگی دارند اما ویژگی‌های بیشتری علاوه بر اندازه را دارند. معیارهای ایستای کد همانند اندازه، پیچیدگی و شئ‌گرایی به منظور بررسی یک نسخه از برنامه مفید هستند اما با هر تکرار\LTRfootnote{Iteration} در فرآیند توسعه‌ی نرم‌افزار دقت پیش‌بینی آنها کاسته می‌شوند و معیارهای فرآیند در چنین شرایطی بهتر عمل می‌کنند.  با این وجود  که  معیارهای فرآیند‌  دارای توانمندی بالقوه‌ای  هستند، اما در تعداد کمتری از پژوهش‌ها مورد استفاده قرار گرفته‌اند\cite{radjenovic2013software}. \\
 
آسترند\LTRfootnote{Ostrand} و همکاران به بررسی این موضوع پرداخته‌اند که آیا اطلاعاتی درباره‌ی اینکه کدام توسعه دهنده یک فایل را اصلاح می‌کند قادر است که پیش‌بینی خطا را بهبود بخشد. در پژوهش قبلی آنها\cite{weyuker2008too} مشخص شده بود که تعداد کلی   افراد توسعه دهنده در یک فایل می‌تواند در پیش‌بینی خطا تاثیر متوسطی داشته باشد. در  مقاله‌ی \cite{ostrand2010programmer}  تعدادی از متغیرهای کد منبع و فرآیند به همراه معیار مرتبط به توسعه دهنده در نظر گرفته شده است.  در این پژوهش مشخص شد  که تعداد خطاهایی که یک توسعه دهنده تولید می‌کند ثابت است و با سایر توسعه دهندگان فرق دارد. این تفاوت با  حجم کدی که یک توسعه دهنده اصلاح می‌کند مرتبط است و در نتیجه در نظر گرفتن یک نویسنده خاص نمی‌تواند به بهبود پیش‌بینی خطا کمک کند\cite{ostrand2010programmer}. \\

رحمان و دوانبو\LTRfootnote{Rahman and Devanbu} از جنبه‌های مختلف معیارهای فرآیند  را با سایر معیارها مقایسه کرده‌اند\cite{rahman2013and}. نتایج نشان می‌دهد  زمانی که مدل پیش‌بینی بر روی یک نسخه آموزش می‌بیند و در نسخه‌ی بعدی آزموده می‌شود معیارهای کد، \lr{AUC} قابل قبولی دارند اما  \lr{AUC}  آنها کمتر از معیارهای فرآیند است  و از نظر معیار 20\% 
\lr{AUCEC} 
بهتر از یک مدل تصادفی عمل نمی‌کنند و  به آن معنی است که این معیارها از نظر هزینه چندان  موثر نیستند. همچنین معیارهای کد ایستاتر هستند، ‌یعنی با تغییرات پروژه و تغییر در توزیع خطاها همچنان معیارها بدون تغییر باقی می‌مانند. معیار ایستا تمایل دارد یک فایل را در انتشارهای\LTRfootnote{Release} متوالی همچنان حاوی خطا معرفی کند. معیارهای ایستا به مدلهای راکد منجر می‌شوند که این مدلها به سمت فایل‌های بزرگ با تراکم خطای کمتر جهت‌گیری\LTRfootnote{Bias} دارند. به عنوان مثال حالتی را در نظر بگیرید که در یک پروژه فایلهای بزرگ و پیچیده‌ای وجود دارد که پس از چندین انتشار خطاهای آنها برطرف می‌شود اما مدلهایی که بر اساس معیارهای کد ساخته شده‌اند همچنان این فایلها را به عنوان خطا‌خیز معرفی می‌کنند. از طرف دیگر حالتی را در نظر بگیرید که یک فایل با اندازه و پیچیدگی کم به تازگی به وجود آمده و یا تغییرات فراوان یافته است. مدلهای مبتنی بر کد به این فایلها توجه چندانی نخواهند کرد در حالیکه که این فایل‌ها مستعد وجود خطا هستند. بدین ترتیب معیارهای فرآیند بهتر از معیارهای کد عمل می‌کنند. 
 
 
